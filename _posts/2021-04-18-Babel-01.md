---
Title: Babel 기초 
Date: 2021-04-18 17:10:00 +0800
Categories: [javascript]
tags: [javascript,babel]
math: true
mermaid: true


---

## 바벨(Babel 7) 기본

자바스크립트 문법은 빠르게 발달 되어가고 있습니다. 하지만 자바스크립트를 실행하는 환경은 이를 받쳐주지 못하는 경우가 많습니다. 그러한 이유로는 브라우저의 종류가 다양하여 모든 브라우저에서 동일하게 문법을 지원하는것이 아니기 때문입니다. 또한 Node.js의 경우 버전에 따라 지원하는 문법이 다르기때문에 브라우저와 동일한 문제를 가지고 있습니다.



#### Babel: JavaScript transpiler

이러한 문제를 해결하기 위해 등장한 것이 바로 자바스크립트 트랜스파일러(transpiler)인 바벨입니다. 바벨을 이용하면 ES6 이상의 최신 문법으로 작성한 자바스크립트 코드를 ES5 이하의 예전 문법으로작성한 것 처럼 소스 코드 내의 문법의 형태를 변경할 수 있습니다. 이렇게 Babel를 통해 문법 평태가 바뀐 소스 코드는 최신 문법을 지원하는 실행 환경 뿐만 아니라 아직 최신 문법들이 적용 되지 않은 실행 환경에서도 문제없이 작동하게 됩니다.



#### TypeScript와 JSX지원 

Babel은  ES6 이상의 최신 문법 뿐만 아니라  TypeScript나 JSX로 작성된 코드를 변환할 때도 많이 사용됩니다.
React는 일반적으로 JSX라는 특수한 문법을 사용하여 코딩을 하기 때문에 개발자가 작성한 원본 코드는 브라우저에서 제대로 실행이 되지 않습니다. 따라서 보통 Webpack 번들러와 Babel 로더를 이용하여 React 프로젝트를 빌드합니다.



#### 바벨의 기본 동작

바벨은 ECMAScript2015 이상의 코드를 적당한 하위 버전으로 바꾸는 것이 주된 역활이다. 이렇게 바뀐 코드는 인터넷 익스플로러나 구버전 브라우저처럼 최신 자바스크립트 코드를 이해하지 못하는 환경에서도 잘 작동한다.

먼저 Babel 최신 버전을 설치한다. 터미널 도구를 사용하기 위해 커맨드라인 도구도 함께 설치한다.

```bash
mkdir babel-example
cd babel-example
npm init -y
npm install -D @babel/core @babel/cli
```

설치를 완료후 node_modules/.bin 폴더에 추가된 바벨 명령어를 사용할 수 있다. 

- app.js

```javascript
const alert = msg => window.alert(msg)
```



```bash
➜  babel-example git:(master) ✗ npx babel app.js
const alert = msg => window.alert(msg);
```

위의 결과에서 어떠한 변화도 없다....



Babel은 세 단계로 빌드를 진행한다.

1. 파싱(Parsing)
2. 변환(Transforming)
3. 출력 (Printing)

코드를 읽고 추상 구문 트리(AST)로 변환하는 단계를 "파싱"이라고 한다. 이것은 빌드 작업을 처리하기에 적합한 자료구조인데 컴파일러 이론에 사용되는 개념이다. 추상 구문 트리를 변경하는 것이 "변환" 단계이다. 실제로 코드를 변경하는 작업을 한다. 변경된 결과물을 "출력"하는 것을 마지막으로 바벨은 작업을 완료한다.



### 플러그인

기본적으로 바벨은 코드를 받아서 코드를 반환한다. 바벨 함수를 정의한다면 이런 모습이 될 것이다.

```javascript
const babel = code => code
```

바벨은 **파싱**과 **출력**만 담당하고 가운데의 **변환**작업은 다른 녀석이 처리하는데 이것이 **플러그인 이다.**

#### Custom Plugin

Plugin을 직접 만들면서 동작 원리를 살펴 보자. Myplugin.js 라는 파일을 아래처럼 만들어보자

[출처:[바벨 홈페이지 코드](https://babeljs.io/docs/en/plugins#plugin-development)]

- myplugin.js

```javascript
module.exports = function myplugin() {
        return {
    visitor: {
      Identifier(path) {
        const name = path.node.name;
				// 바벨이 만든 AST 노드를 출력한다
        console.log("Identifier() name:", name)
        // 이름의 문자열을 역순으로 설정 홍길동 => 동길홍
        path.node.name = name
                .split("")
                .reverse()
                .join("");
      },
    },
  };
}
```

Plugin 형식은 vistor 객체를 가진 함수를 반환해야 한다. 이 객체는 Babel이 파싱하여 만든 추상 구문 트리(AST)에 접근할 수 있는 메소드를 제공한다. 그 중 Identifier() 메소드의 동작 원리를 살펴보았다.

Plugin 사용법을 알아보자.

```bash
npx babel --help
--plugins [list]                            A comma-separated list of plugin names.
```

`--plugins` 옵션에 plugin을 추가하면 된다.

```bash
npx babel app.js --plugins ./myplugin.js

Identifier() name: alert
Identifier() name: msg
Identifier() name: window
Identifier() name: alert
Identifier() name: msg

const trela = gsm => wodniw.trela(gsm);
```

Identifier() 메소드로 들어온 인자 path에 접근하면 코드 조각에 접근할 수 있는 것 같다.
path.node.name의 문자열을 역전하는것이 결과로 보인다.

ECMASCript2015로 작성한 코드를 인터넷 익스플로러에서 돌리려면 `const` 코드를 `var`로 변경이 필요하다.  그러한 plugin을 만들어보자

```javascript
module.exports = function myplugin() {
        return {
    visitor: {
      VariableDeclaration(path) {
        console.log("VariableDeclaration() kind:", path.node.kind) // const
				if (path.node.kind === "const") {
          path.node.kind = "var"
        }
      },
    },
  };
}
```

이번에는 vistor 객체에 VariableDeclaration() 메소드를 정의했다. path에 접근해 보면 키워드가 잡히는 것을 알 수 있다. path.node.kind가 `const` 일 경우 `var`로 변환해주는 plugin이다.

이 plugin으로 다시 빌드해보자.

```bash
npx babel app.js --plugins ./myplugin.js 
VariableDeclaration() kind: const
var alert = msg => window.alert(msg);
```

마지막 줄을 보면 `const`가 `var`로 바뀐걸 확인 할 수 있다.



#### Plugin 사용하기

위의 plugin과 같은 결과를 만드는 것이 <u>block-scoping</u> 플러그인이다.  `const`, `let` 과 같은 예약어를 `var`로 변경한다.

NPM 패키지로 제공하는 plugin을 설치하고,

```bash
npm install -D @babel/plugin-transform-block-scoping
```

설치한 plugin을 사용해보자.

```bash
npx babel app.js --plugins @babel/plugin-transform-block-scoping

var alert = msg => window.alert(msg);
```

위에서 작성한 plugin과 동일한 결과가 나온다.

인터넷 익스플로러는 화살표 함수도 지원하지 않아서 여전히 app.js 를 사용할 수 없다. 그래서 <u>arrow-functions</u>플러그인을 이용해서 일반 함수로 변경할 수 있다.

```
npm install -D @babel/plugin-transform-arrow-functions

npx babel app.js \
  --plugins @babel/plugin-transform-block-scoping \
  --plugins @babel/plugin-transform-arrow-functions
  
var alert = function (msg) {
  return window.alert(msg);
};
```

ECMAScript5에서부터 지원하는 엄격 모드를 사용하는 것이 안전하기 때문에 `"use strict"`구문을 추가하자. 추가를 하기 위해 <u>strict-mode</u>플러그인을 이용

그 전에 커맨드라인 명령어가 점점 길어지기 때문에 설정 파일로 분리하는 것이 좋을듯 싶다. Webpack가 webpack.config.js 를 기본 설정 파일로 사용하듯 Babel 또한 babel.config.js 를 기본 설정파일로 사용된다.

프로젝트 루트에 babel.config.js 파일을 아래와 같이 작성하자.

- babel.config.js

```javascript
module.exports = {
  plugins: [
    "@babel/plugin-transform-block-scoping",
    "@babel/plugin-transform-arrow-functions",
    "@babel/plugin-transform-strict-mode",
  ],
}
```

